import { create } from 'zustand';
import { CreatureSize } from '../utils/gridHelpers';

export type Vector3 = { x: number; y: number; z: number };

export interface EntityMetadata {
  hp: {
    current: number;
    max: number;
    temp?: number;
  };
  ac: number;
  creatureType: string;
  conditions: string[];
  stats?: {
    str: number;
    dex: number;
    con: number;
    int: number;
    wis: number;
    cha: number;
  };
  description?: string;
  notes?: string;
}

export interface Entity {
  id: string;
  name: string;
  type: 'character' | 'npc' | 'monster';
  size: CreatureSize;
  position: Vector3;
  color: string;
  model?: string;
  metadata: EntityMetadata;
}

export interface GridConfig {
  size: number;
  divisions: number;
}

export interface TerrainFeature {
  id: string;
  type: string;
  position: Vector3;
  dimensions: { width: number; height: number; depth: number };
  blocksMovement: boolean;
  coverType?: 'half' | 'three-quarters' | 'full' | 'none';
  color: string;
}

interface CombatState {
  entities: Entity[];
  terrain: TerrainFeature[];
  selectedEntityId: string | null;
  gridConfig: GridConfig;
  battlefieldDescription: string | null;

  addEntity: (entity: Entity) => void;
  removeEntity: (id: string) => void;
  updateEntity: (id: string, updates: Partial<Entity>) => void;
  updateEntityMetadata: (id: string, metadata: Partial<EntityMetadata>) => void;
  selectEntity: (id: string | null) => void;
  setGridConfig: (config: GridConfig) => void;
  setBattlefieldDescription: (desc: string | null) => void;
  syncCombatState: () => Promise<void>;
}

const MOCK_ENTITIES: Entity[] = [];

function parseBattlefieldText(text: string): { entities: Entity[]; terrain: TerrainFeature[]; gridConfig: GridConfig } {
  const entities: Entity[] = [];
  const terrain: TerrainFeature[] = [];
  let gridConfig: GridConfig = { size: 20, divisions: 20 };
  
  console.log('[parseBattlefieldText] Raw text:', text);
  
  try {
    const battlefieldMatch = text.match(/âš”ï¸\s+\*\*BATTLEFIELD\*\*:\s+(\d+)Ã—(\d+)\s+squares/);
    if (battlefieldMatch) {
      const width = parseInt(battlefieldMatch[1]);
      const height = parseInt(battlefieldMatch[2]);
      gridConfig = { size: Math.max(width, height), divisions: Math.max(width, height) };
    }
    
    // Parse terrain section
    const terrainSectionMatch = text.match(/ðŸ—ï¸\s+\*\*TERRAIN\*\*:([\s\S]*?)(?=ðŸ‘¥\s+\*\*COMBATANTS\*\*:|$)/);
    if (terrainSectionMatch) {
      const terrainSection = terrainSectionMatch[1];
      console.log('[parseBattlefieldText] Terrain section found:', terrainSection);
      
      // Split by bullet point 'â€¢' to handle both newline and inline formatting
      const terrainItems = terrainSection.split('â€¢')
        .map(item => item.trim())
        .filter(item => item.length > 0);
      
      console.log('[parseBattlefieldText] Found', terrainItems.length, 'terrain items');
      
      terrainItems.forEach((item, index) => {
        try {
          // Example: Wall at (5,3) - 1Ã—1Ã—5ft [blocks movement]
          const posMatch = item.match(/at\s+\((\d+),(\d+)\)\s*-\s*(\d+)Ã—(\d+)Ã—(\d+)ft/);
          const typeMatch = item.match(/^([^\s]+)/);
          
          if (posMatch && typeMatch) {
            const mcpX = parseInt(posMatch[1]);
            const mcpY = parseInt(posMatch[2]);
            const widthFt = parseInt(posMatch[3]);
            const lengthFt = parseInt(posMatch[4]); // 2D depth/length
            const heightFt = parseInt(posMatch[5]); // Vertical height
            const terrainType = typeMatch[1].toLowerCase();
            
            const blocksMovement = item.includes('[blocks movement]');
            let coverType: 'half' | 'three-quarters' | 'full' | 'none' = 'none';
            if (item.includes('[half cover]')) coverType = 'half';
            else if (item.includes('[three-quarters cover]')) coverType = 'three-quarters';
            else if (item.includes('[full cover]')) coverType = 'full';
            
            let color = '#808080';
            if (terrainType === 'wall') color = '#555555';
            else if (terrainType === 'pillar') color = '#666666';
            else if (terrainType.includes('difficult')) color = '#8b4513';
            
            // Convert dimensions (5ft = 1 grid unit)
            const width = widthFt / 5;
            const depth = lengthFt / 5; // Z-axis dimension
            let height = heightFt / 5;  // Y-axis dimension
      }
    });
    
  } catch (error) {
    console.error('[parseBattlefieldText] Error parsing battlefield text:', error);
  }
  
  console.log('[parseBattlefieldText] Final parsed entities:', entities);
  console.log('[parseBattlefieldText] Final parsed terrain:', terrain);
  return { entities, terrain, gridConfig };
}

export const useCombatStore = create<CombatState>((set) => ({
  entities: MOCK_ENTITIES,
  terrain: [],
  selectedEntityId: null,
  gridConfig: { size: 10, divisions: 10 },
  battlefieldDescription: null,

  addEntity: (entity) => set((state) => ({
    entities: [...state.entities, entity]
  })),

  removeEntity: (id) => set((state) => ({
    entities: state.entities.filter((ent) => ent.id !== id),
    selectedEntityId: state.selectedEntityId === id ? null : state.selectedEntityId
  })),

  updateEntity: (id, updates) => set((state) => ({
    entities: state.entities.map((ent) =>
      ent.id === id ? { ...ent, ...updates } : ent
    )
  })),

  updateEntityMetadata: (id, metadata) => set((state) => ({
    entities: state.entities.map((ent) => {
      if (ent.id !== id) return ent;
      const newMetadata = { ...ent.metadata, ...metadata };
      
      if (metadata.hp) {
        newMetadata.hp = { ...ent.metadata.hp, ...metadata.hp };
      }
      
      if (metadata.stats) {
        newMetadata.stats = { ...(ent.metadata.stats || {}), ...metadata.stats } as any;
      }

      return { ...ent, metadata: newMetadata };
    })
  })),

  selectEntity: (id) => set({ selectedEntityId: id }),

  setGridConfig: (config) => set({ gridConfig: config }),
  
  setBattlefieldDescription: (desc) => set({ battlefieldDescription: desc }),

  syncCombatState: async () => {
    try {
      const { mcpManager } = await import('../services/mcpClient');
      
      try {
        console.log('[syncCombatState] Calling describe_battlefield...');
        const result = await mcpManager.combatClient.callTool('describe_battlefield', {});
        
        if (result && result.content && result.content[0].text) {
             const text = result.content[0].text;
             console.log('[syncCombatState] Received battlefield text');
             set({ battlefieldDescription: text });
             
             const parsedState = parseBattlefieldText(text);
             
             console.log('[syncCombatState] Parsed', parsedState.entities.length, 'entities');
             console.log('[syncCombatState] Parsed', parsedState.terrain.length, 'terrain features');
             
             if (parsedState.entities.length > 0 || parsedState.terrain.length > 0) {
               set({ 
                 entities: parsedState.entities,
                 terrain: parsedState.terrain,
                 gridConfig: parsedState.gridConfig
               });
             } else {
               console.warn('[syncCombatState] No entities/terrain parsed, keeping current state');
             }
        }
      } catch (e) {
        console.warn('[syncCombatState] Failed to sync combat state:', e);
      }
    } catch (error) {
      console.error('[syncCombatState] Error syncing combat state:', error);
    }
  }
}));